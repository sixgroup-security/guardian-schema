# This file is part of Guardian.
#
# Guardian is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Guardian is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with MyAwesomeProject. If not, see <https://www.gnu.org/licenses/>.

import uuid
import inspect
from datetime import datetime
from typing import Optional, Dict, Set, List, Any
from sqlmodel import Field, SQLModel, Relationship
from sqlalchemy import UniqueConstraint, Column, ForeignKey
from pydantic import BaseModel, ConfigDict, Field as PydanticField, computed_field
from sqlalchemy import Enum
from sqlalchemy.sql import func
from sqlalchemy.dialects import postgresql
from schema.tagging import TagMeasureGeneral, Tag, TagLookup
from schema.util import ProjectType, multi_language_field_model_validator
from schema.reporting.report_language import ReportLanguage

__author__ = "Lukas Reiter"
__copyright__ = "Copyright (C) 2024 Lukas Reiter"
__license__ = "GPLv3"


class MeasureLanguage(SQLModel, table=True):
    """
    This is the schema for managing language-specific fields for measures.
    """
    id: Optional[uuid.UUID] = Field(primary_key=True,
                                    index=True,
                                    sa_column_kwargs=dict(server_default=func.gen_random_uuid()))
    recommendation: str = Field()
    # Foreign keys
    language_id: uuid.UUID = Field(foreign_key="reportlanguage.id")
    measure_id: uuid.UUID = Field(
        sa_column=Column(ForeignKey("measure.id", ondelete="CASCADE"), nullable=False)
    )
    # Internal information only
    created_at: datetime = Field(sa_column_kwargs=dict(server_default=func.now()))
    last_modified_at: Optional[datetime] = Field(sa_column_kwargs=dict(onupdate=func.now()))
    # All relationship definitions
    # https://github.com/tiangolo/sqlmodel/issues/10
    language: ReportLanguage = (
        Relationship(sa_relationship_kwargs=dict(foreign_keys="[MeasureLanguage.language_id]"),
                     back_populates="measure_details"))
    measure: "Measure" = (
        Relationship(sa_relationship_kwargs=dict(foreign_keys="[MeasureLanguage.measure_id]"),
                     back_populates="multi_language_fields"))

    __table_args__ = (
        UniqueConstraint('language_id', 'measure_id'),
    )


class Measure(SQLModel, table=True):
    """
    Store information about a measure
    """
    id: Optional[uuid.UUID] = Field(primary_key=True,
                                    index=True,
                                    sa_column_kwargs=dict(server_default=func.gen_random_uuid()))
    # TODO: Should be language specific
    name: str = Field(index=True, unique=True)
    project_types: List[ProjectType] = Field(
        default={},
        sa_column=Column(postgresql.ARRAY(Enum(ProjectType)), nullable=False)
    )
    # Internal information only
    created_at: datetime = Field(sa_column_kwargs=dict(server_default=func.now()))
    last_modified_at: Optional[datetime] = Field(sa_column_kwargs=dict(onupdate=func.now()))
    # All relationship definitions
    # https://github.com/tiangolo/sqlmodel/issues/10
    multi_language_fields: List[MeasureLanguage] = Relationship(
        sa_relationship_kwargs=dict(cascade="all,delete,delete-orphan"),
        back_populates="measure"
    )
    general_tags: List[Tag] = Relationship(back_populates="measures_general", link_model=TagMeasureGeneral)
    vulnerability_templates: List["VulnerabilityTemplate"] = Relationship(
        sa_relationship_kwargs=dict(
            secondary="vulnerabilitytemplatemeasure",
            back_populates="measures"
        )
    )

    def _get_language(self, language: ReportLanguage, raise_not_found: bool = False) \
            -> Optional[MeasureLanguage]:
        """
        Returns the correct TestProcedureLanguage object based on the given ReportLanguage object.
        """
        result = [item for item in self.multi_language_fields if item.language_id == language.id]
        if not result and raise_not_found:
            raise ValueError()
        return result[0] if result else None

    def get_recommendation(self, language,  default: str = None):
        result = self._get_language(language)
        return result.recommendation if result else default


class VulnerabilityMeasureLookup(BaseModel):
    """
    This schema is used to display the list of vulnerabilities in the Vulnerability reporting form.
    """
    id: uuid.UUID
    name: str
    recommendation: str


class MeasureCreateUpdateBase(BaseModel):
    """
    This is the base schema for updating or creating a measure.
    """
    name: str
    project_types: Set[ProjectType]

    def __eq__(self, other: Any) -> bool:
        return self.name == other.name and self.project_types == other.project_types


class MeasureCreate(MeasureCreateUpdateBase):
    """
    This is the measure schema for creating, reading and updating a measure via FastAPI.
    """
    recommendation: Dict[str, str]
    general_tags: List[uuid.UUID] | None = PydanticField(default=[])


class MeasureUpdate(MeasureCreate):
    """
    This is the schema for updating a measure via FastAPI.
    """
    id: uuid.UUID


class MeasureRead(MeasureCreateUpdateBase):
    """
    This is the measure schema. It is used by the FastAPI to read a measure.
    """
    model_config = ConfigDict(from_attributes=True, extra="ignore")

    id: uuid.UUID
    multi_language_fields: List[MeasureLanguage] = PydanticField(exclude=True)
    vulnerability_templates: List[Any] = PydanticField(default=[], exclude=True)
    general_tags: List[TagLookup] | None = PydanticField(default=[])

    @computed_field
    def recommendation(self) -> Dict[str, str]:
        return multi_language_field_model_validator(self, inspect.currentframe())

    @computed_field
    def vulnerability_count(self) -> int:
        return len(self.vulnerability_templates)


class MeasureResponse(MeasureCreateUpdateBase):
    """
    This class can be used to parse the JSON response of measure GET, POST or PUT API operations.
    """
    id: uuid.UUID
    recommendation: Dict[str, str]
    vulnerability_templates: List[Any] = PydanticField(default=[], exclude=True)

    @computed_field
    def vulnerability_count(self) -> int:
        return len(self.vulnerability_templates)

    def __eq__(self, other) -> bool:
        return (
            super().__eq__(other)
            and self.id == other.id
            and self.recommendation == other.recommendation
            and self.vulnerability_count == other.vulnerability_count
        )


class MeasureLookup(SQLModel):
    id: uuid.UUID
    name: str
