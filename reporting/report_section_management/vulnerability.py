# This file is part of Guardian.
#
# Guardian is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Guardian is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Guardian. If not, see <https://www.gnu.org/licenses/>.

import re
import uuid
import enum
from typing import List
from sqlmodel import SQLModel, Field, Relationship
from sqlalchemy.orm import backref
from sqlalchemy.sql import func
from sqlalchemy import INTEGER, ForeignKey, Column, text
from sqlalchemy.schema import Sequence

from schema.reporting.file import File, FileReport
from schema.reporting import VulnerabilityBase, ReportCreationStatus
from schema.reporting.vulnerability.rating import RatingBase, SeverityType
from schema.reporting.vulnerability.vulnerability_template import VulnerabilityTemplate, VulnerabilityTemplateReport
from schema.tagging.bugcrowd_vrt import Vrt, VrtReport, VrtLookup
from schema.tagging.mitre_cwe import CweWeakness, CweLookup, CweReport
from schema.tagging import Tag, TagLookup
from pydantic import BaseModel, ConfigDict, Field as PydanticField, computed_field
from datetime import datetime

__author__ = "Lukas Reiter"
__copyright__ = "Copyright (C) 2024 Lukas Reiter"
__license__ = "GPLv3"


class VulnerabilityStatus(enum.IntEnum):
    draft = 0
    review = 10
    final = 20
    resolved = 100
    hide = 110


class IncompleteVulnerabilityError(Exception):
    """
    Raised when a vulnerability is incomplete.
    """
    pass


class VulnerabilityFile(SQLModel, table=True):
    vulnerability_id: uuid.UUID = Field(
        sa_column=Column(ForeignKey("vulnerability.id", ondelete="CASCADE"), primary_key=True))
    file_id: uuid.UUID = Field(
        sa_column=Column(ForeignKey("file.id", ondelete="CASCADE"), primary_key=True))
    # Internal information only
    created_at: datetime = Field(sa_column_kwargs=dict(server_default=func.now()))
    last_modified_at: datetime | None = Field(sa_column_kwargs=dict(onupdate=func.now()))
    # Relationship definitions
    vulnerability: List["Vulnerability"] = Relationship(
        sa_relationship_kwargs=dict(backref=backref("file_mappings",
                                                    cascade="delete, delete-orphan",
                                                    overlaps="vulnerabilities,files"),
                                    overlaps="vulnerabilities,files")
    )
    file: List["File"] = Relationship(
        sa_relationship_kwargs=dict(backref=backref("vulnerability_mappings",
                                                    cascade="delete, delete-orphan",
                                                    overlaps="vulnerabilities,files"),
                                    overlaps="vulnerabilities,files")
    )


class Vulnerability(VulnerabilityBase, RatingBase, table=True):
    """
    Store information about a procedure
    """
    name: str = Field(index=True)
    description: str = Field()
    observation: str = Field()
    # Simple ID (instead of UUID) allowing users to cross-reference vulnerabilities (e.g., via \nameref{$reference})
    reference: int = Field(
        sa_column=Column(
            INTEGER,
            # TODO: Set this individually per project to avoid disclosure of vulnerability count.
            Sequence('vulnerability_ref_seq', start=1001, increment=1),
            server_default=text("nextval('vulnerability_ref_seq')"),
            unique=True,
            autoincrement=True,
            nullable=False
        )
    )
    vulnerability_id: int = Field(sa_column_kwargs=dict(server_default="1"))
    # Allows penetration testers to mark a vulnerability description to become a potential procedure template
    template_candidate: bool = Field(default=False, sa_column_kwargs=dict(server_default="false"))
    # We need to create a copy of the measure because it might change in the future
    measure_title: str = Field()
    measure_recommendation: str = Field()
    rating_comment: str | None = Field()
    status: VulnerabilityStatus = Field(sa_column_kwargs=dict(server_default=VulnerabilityStatus.draft.name))
    creation_status: ReportCreationStatus | None = Field()
    # Contains the current version as a PDF file
    pdf: bytes | None = Field()
    # Contains the creation logs for the PDF file
    pdf_log: bytes | None = Field()
    # Contains the Latex source files for creating the PDF file
    tex: bytes | None = Field()
    # Foreign keys
    procedure_id: uuid.UUID | None = Field(foreign_key="reportprocedure.id")
    report_section_id: uuid.UUID = Field(
        sa_column=Column(
            ForeignKey("reportsection.id", ondelete="CASCADE"),
            nullable=False
        )
    )
    # Documents that the procedure was a retest or duplicate of an already existing procedure.
    retest_id: uuid.UUID | None = Field(foreign_key="vulnerability.id")
    # Documents the source vulnerability template on which this vulnerability is based on.
    source_template_id: uuid.UUID | None = Field(foreign_key="vulnerabilitytemplate.id")
    # All relationship definitions
    # https://github.com/tiangolo/sqlmodel/issues/10
    vrt: Vrt | None = Relationship(back_populates="vulnerabilities")
    cwe_weakness: CweWeakness | None = Relationship()
    source_template: VulnerabilityTemplate | None = (
        Relationship(
            sa_relationship_kwargs=dict(foreign_keys="[Vulnerability.source_template_id]"),
            back_populates="vulnerabilities"
        )
    )
    files: List[File] = Relationship(
        sa_relationship_kwargs=dict(cascade="all", secondary="vulnerabilityfile", back_populates="vulnerabilities")
    )
    procedure: "ReportProcedure" = Relationship(back_populates="vulnerabilities")
    report_section: "ReportSection" = Relationship(back_populates="vulnerabilities")
    original_vulnerability: "Vulnerability" = (
        Relationship(
            sa_relationship_kwargs=dict(foreign_keys="[Vulnerability.retest_id]", remote_side="Vulnerability.id"),
            back_populates="retests"
        )
    )
    retests: List["Vulnerability"] = Relationship(back_populates="original_vulnerability")

    @property
    def vulnerability_id_str(self) -> str:
        return f"ID-{self.vulnerability_id:03d}"

    def get_file(self, file_id: uuid.UUID) -> File | None:
        """
        Get the file with the given ID.
        """
        for file in self.files:
            if file.id == file_id:
                return file
        return None

    def check_complete(self, with_status: bool = True):
        """
        Check if the vulnerability is complete.
        """
        # Lookup: Check Report Version
        if with_status and self.status in [VulnerabilityStatus.draft]:
            raise IncompleteVulnerabilityError(
                f"Vulnerability {self.vulnerability_id_str} is in status {self.status.name.capitalize()} but it "
                f"must be in Final, Resolved or Hide to create a report version."
            )
        if not self.name:
            raise IncompleteVulnerabilityError(f"Name is missing in vulnerability {self.vulnerability_id_str}")
        if not self.description:
            raise IncompleteVulnerabilityError(f"Description is missing in vulnerability {self.vulnerability_id_str}")
        if not self.observation:
            raise IncompleteVulnerabilityError(f"Observation is missing in vulnerability {self.vulnerability_id_str}")
        if not self.measure_title:
            raise IncompleteVulnerabilityError(
                f"Measure title is missing in vulnerability {self.vulnerability_id_str}"
            )
        if not self.measure_recommendation:
            raise IncompleteVulnerabilityError(
                f"Measure recommendation is missing in vulnerability {self.vulnerability_id_str}"
            )
        if self.severity is None:
            raise IncompleteVulnerabilityError(f"Severity is missing in vulnerability {self.vulnerability_id_str}")

    def contains_file(self, file: File) -> bool:
        """
        Checks if the given file is used by the vulnerability.
        """
        file_id = str(file.id)
        return (
                file_id in (self.description or "") or
                file_id in (self.observation or "") or
                file_id in (self.references or "") or
                file_id in (self.measure_title or "") or
                file_id in (self.measure_recommendation or "") or
                file_id in (self.rating_comment or "")
        )

    @staticmethod
    def clone_from_template(language, template, **kwargs):
        """
        Create an object based on the given VulnerabilityTemplate object.
        """
        return Vulnerability(
            name=template.get_title(language),
            description=template.get_description(language),
            observation=template.get_observation(language),
            measure_title="",
            measure_recommendation="",
            source_template=template,
            vrt_id=template.vrt_id,
            cwe_weakness_id=template.cwe_weakness_id,
            references=template.references,
            source_template_id=template.id,
            **kwargs
        )

    @staticmethod
    def create_empty(title: str, **kwargs):
        """
        Create an empty vulnerability.
        """
        return Vulnerability(
            name=title,
            description="",
            observation="",
            measure_title="",
            measure_recommendation="",
            **kwargs
        )


class VulnerabilityCreateUpdateBase(BaseModel):
    """
    This is the vulnerability schema for reading and updating a vulnerability via FastAPI.
    """
    name: str
    status: VulnerabilityStatus
    description: str | None = PydanticField(default="")
    observation: str | None = PydanticField(default="")
    template_candidate: bool | None = PydanticField(default=None)
    measure_title: str | None = PydanticField(default="")
    measure_recommendation: str | None = PydanticField(default="")
    references: str | None = PydanticField(default=None)
    cvss_score: float | None = PydanticField(default=None)
    cvss_vector: str | None = PydanticField(default=None)
    rating_comment: str | None = PydanticField(default=None)


class VulnerabilityUpdate(VulnerabilityCreateUpdateBase):
    """
    This is the vulnerability schema for updating a vulnerability via FastAPI.
    """
    severity: SeverityType | None = PydanticField(default=None)
    vrt_id: uuid.UUID | None = PydanticField(default=None, alias="vrt")
    cwe_weakness_id: uuid.UUID | None = PydanticField(default=None, validation_alias="cwe_weakness")


class VulnerabilityRead(VulnerabilityCreateUpdateBase):
    """
    This is the vulnerability schema for reading a vulnerability via FastAPI.
    """
    id: uuid.UUID
    vulnerability_id: int
    severity: SeverityType | None = PydanticField(default=None)
    source_template_id: uuid.UUID | None = PydanticField(default=None)
    vrt_local: VrtLookup | None = PydanticField(default=None, exclude=True, validation_alias="vrt")
    cwe_weakness_local: CweLookup | None = PydanticField(default=None, exclude=True, validation_alias="cwe_weakness")
    status: VulnerabilityStatus = PydanticField()
    creation_status: ReportCreationStatus | None = PydanticField(default=None)
    pdf: bytes | None = PydanticField(default=None, exclude=True)
    pdf_log: bytes | None = PydanticField(default=None, exclude=True)
    tex: bytes | None = PydanticField(default=None, exclude=True)
    source_template: VulnerabilityTemplate | None = PydanticField(default=None, exclude=True)

    @computed_field
    def vrt(self) -> VrtLookup | None:
        if self.source_template and self.source_template.vrt:
            return VrtLookup(
                id=self.source_template.vrt.id,
                category=self.source_template.vrt.category,
            )
        return self.vrt_local

    @computed_field
    def cwe_weakness(self) -> CweLookup | None:
        if self.source_template and self.source_template.cwe_weakness:
            return CweLookup(
                id=self.source_template.cwe_weakness.id,
                cwe_id=self.source_template.cwe_weakness.cwe_id,
                name=self.source_template.cwe_weakness.name
            )
        return CweLookup(
            id=self.cwe_weakness_local.id,
            cwe_id=self.cwe_weakness_local.cwe_id,
            name=self.cwe_weakness_local.name
        ) if self.cwe_weakness_local else None

    @computed_field
    def has_pdf(self) -> bool:
        return self.pdf is not None and len(self.pdf) > 0

    @computed_field
    def has_pdf_log(self) -> bool:
        return self.pdf_log is not None and len(self.pdf_log) > 0

    @computed_field
    def has_tex(self) -> bool:
        return self.tex is not None and len(self.tex) > 0

    @computed_field
    def vulnerability_id_str(self) -> str:
        return f"ID-{self.vulnerability_id:03d}"


class VulnerabilityTreeNode(BaseModel):
    model_config = ConfigDict(from_attributes=True)
    id: uuid.UUID
    name: str
    reference: int = PydanticField(exclude=True)
    status: int
    severity: int | None
    vulnerability_id: int
    type: str = "vulnerability"
    pdf: bytes | None = PydanticField(default=None, exclude=True)
    pdf_log: bytes | None = PydanticField(default=None, exclude=True)
    tex: bytes | None = PydanticField(default=None, exclude=True)

    @computed_field
    def has_pdf(self) -> bool:
        return self.pdf is not None and len(self.pdf) > 0

    @computed_field
    def has_pdf_log(self) -> bool:
        return self.pdf_log is not None and len(self.pdf_log) > 0

    @computed_field
    def has_tex(self) -> bool:
        return self.tex is not None and len(self.tex) > 0

    @computed_field
    def reference_str(self) -> str:
        return f"{self.reference:05d}"

    @computed_field
    def vulnerability_id_str(self) -> str:
        return f"ID-{self.vulnerability_id:03d}"


class VulnerabilityReport(BaseModel):
    """
    Schema for creating the final JSON object based on which the report is created.
    """
    model_config = ConfigDict(from_attributes=True)
    id: uuid.UUID
    reference: int
    name: str
    status: VulnerabilityStatus
    description: str
    observation: str
    measure_title: str
    measure_recommendation: str
    references: str | None = PydanticField(default="")
    severity: SeverityType | None
    cvss_score: float | None = PydanticField(default=None)
    cvss_vector: str | None = PydanticField(default=None)
    rating_comment: str | None = PydanticField(default="")
    nonconformity: bool | None = PydanticField(default=None)
    vrt: VrtReport | None = PydanticField(default=None)
    cwe_weakness: CweReport | None = PydanticField(default=None)
    files: List[FileReport] = PydanticField(default=[])
    vulnerability_id: int
    source_template: VulnerabilityTemplateReport | None = PydanticField(default=None)

    @property
    def reference_str(self) -> str:
        return f"{self.reference:05d}"

    @computed_field
    def vulnerability_id_str(self) -> str:
        return f"ID-{self.vulnerability_id:03d}"

    @computed_field
    def status_str(self) -> str:
        return self.status.name.capitalize() if self.status else ""

    @computed_field
    def severity_str(self) -> str:
        return self.severity.name.capitalize() if self.severity else ""

    @computed_field
    def visible(self) -> bool:
        # Lookup: Check Report Version
        return (
                self.status not in [VulnerabilityStatus.draft, VulnerabilityStatus.hide] and
                self.severity and self.severity.value >= SeverityType.low
        )

    @computed_field
    def vrt_str(self) -> str:
        result = (self.source_template.vrt
                  if self.source_template and self.source_template.vrt else self.vrt)
        return result.label if result else "n/a"

    @computed_field
    def cwe_weakness_id(self) -> str | None:
        result = (self.source_template.cwe_weakness
                  if self.source_template and self.source_template.cwe_weakness else self.cwe_weakness)
        return str(result.cwe_id) if result else None

    @computed_field
    def cwe_weakness_str(self) -> str | None:
        result = (self.source_template.cwe_weakness
                  if self.source_template and self.source_template.cwe_weakness else self.cwe_weakness)
        return result.label if result else None
